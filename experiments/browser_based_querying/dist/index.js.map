{"version":3,"file":"index.js","mappings":";;;AAAA;AACA;AACA;AACA;AACA;AACA;;;;ACLA;AACA;AACA;AACA;AACA;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrBA;AACA;AAEA;AACA;AAEA;AAEA;AAAA;AAAA;;AAEA;AACA;AAAA;AAAA;;AAEA;AACA;AACA;;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AAHA;AAKA;;AAEA;AACA;AACA;AADA;AAGA;;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA","sources":["webpack://browser-based-querying/webpack/bootstrap","webpack://browser-based-querying/webpack/runtime/get javascript chunk filename","webpack://browser-based-querying/webpack/runtime/global","webpack://browser-based-querying/webpack/runtime/hasOwnProperty shorthand","webpack://browser-based-querying/webpack/runtime/publicPath","webpack://browser-based-querying/webpack/runtime/jsonp chunk loading","webpack://browser-based-querying/./src/index.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// This function allow to reference async chunks\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".js\";\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript)\n\t\tscriptUrl = document.currentScript.src\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) scriptUrl = scripts[scripts.length - 1].src\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","__webpack_require__.b = document.baseURI || self.location.href;\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t\"index\": 0\n};\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n// no on chunks loaded\n\n// no jsonp function","const queryBox = document.getElementById('query')! as HTMLTextAreaElement;\nconst varsBox = document.getElementById('vars')! as HTMLTextAreaElement;\n\nconst runButton = document.getElementById('run')! as HTMLButtonElement;\nconst moreButton = document.getElementById('more')! as HTMLButtonElement;\n\nconst resultsBox = document.getElementById('results')! as HTMLTextAreaElement;\n\nconst queryWorker = new Worker(new URL('./adapter', import.meta.url), { type: 'module' });\n\nfunction setup(then: () => void): void {\n  queryWorker.postMessage({ op: 'init' });\n\n  function cleanUp() {\n    queryWorker.removeEventListener('message', awaitInitConfirmation);\n  }\n\n  function awaitInitConfirmation(e: MessageEvent) {\n    const data = e.data;\n    if (data === 'ready') {\n      cleanUp();\n      then();\n    } else {\n      throw new Error(`Unexpected message: ${data}`);\n    }\n  }\n  queryWorker.onmessage = awaitInitConfirmation;\n}\n\nfunction enableUI(): void {\n  queryWorker.onmessage = handleQueryMessage;\n  queryWorker.onmessageerror = handleQueryError;\n\n  runButton.disabled = false;\n  runButton.onclick = runQuery;\n  moreButton.onclick = nextResult;\n}\n\nsetup(enableUI);\n\nfunction runQuery(): void {\n  resultsBox.textContent = '';\n\n  const query = queryBox.value;\n  let vars;\n  if (varsBox.value === null) {\n    vars = {};\n  } else {\n    try {\n      vars = JSON.parse(varsBox.value);\n    } catch (e) {\n      resultsBox.textContent = `Invalid variables data: ${e}`;\n      return;\n    }\n  }\n\n  moreButton.disabled = false;\n\n  queryWorker.postMessage({\n    op: 'query',\n    query,\n    args: vars,\n  });\n}\n\nfunction nextResult(): void {\n  queryWorker.postMessage({\n    op: 'next',\n  });\n}\n\nfunction handleQueryMessage(e: MessageEvent): void {\n  const outcome = e.data;\n  if (outcome.done) {\n    if (!resultsBox.textContent?.endsWith('***')) {\n      resultsBox.textContent += '*** no more data ***';\n      moreButton.disabled = true;\n    }\n  } else {\n    const pretty = JSON.stringify(outcome.value, null, 2);\n    resultsBox.textContent += `${pretty}\\n`;\n  }\n  resultsBox.scrollTop = resultsBox.scrollHeight;\n  resultsBox.scrollIntoView();\n}\n\nfunction handleQueryError(e: MessageEvent): void {\n  moreButton.disabled = true;\n  resultsBox.textContent = `Query error: ${e.data}`;\n}\n"],"names":[],"sourceRoot":""}