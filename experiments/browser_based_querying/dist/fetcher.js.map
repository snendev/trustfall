{"version":3,"file":"fetcher.js","mappings":";;;;;;;;;;;;;;AAKA;AAMA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;;AAEA;AACA;AACA;AACA;AAFA;AAIA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;;;AAGA;AACA;AACA;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA1HA;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACNA;;AAEA;AACA;AACA;AAEA;AAEA;AAEA;;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA","sources":["webpack://browser-based-querying/./src/worker/sync.ts","webpack://browser-based-querying/webpack/bootstrap","webpack://browser-based-querying/webpack/runtime/define property getters","webpack://browser-based-querying/webpack/runtime/hasOwnProperty shorthand","webpack://browser-based-querying/webpack/runtime/make namespace object","webpack://browser-based-querying/./src/worker/fetcher.ts"],"sourcesContent":["export interface SendableSyncContext {\n  contentBuffer: SharedArrayBuffer;\n  ctrlBuffer: SharedArrayBuffer;\n}\n\nexport class SyncContext {\n  contentBuffer: SharedArrayBuffer;\n  ctrlBuffer: SharedArrayBuffer;\n\n  ctrl: Int32Array;\n\n  static CTRL_BUFFER_LENGTH = 12;\n  static CONTENT_BUFFER_LENGTH = 4096;\n\n  static CTRL_OFFSET_STATE = 0;\n  static CTRL_OFFSET_CURRENT_WRITE_SIZE = 1;\n  static CTRL_OFFSET_TOTAL_SIZE = 2;\n\n  static STATE_WAITING_FOR_DATA = 128;\n  static STATE_DONE = 1;\n  static STATE_BUFFER_FULL = 2;\n  static STATE_TERMINATED_ERROR = 3;\n\n  constructor({ ctrlBuffer, contentBuffer }: SendableSyncContext) {\n    this.ctrlBuffer = ctrlBuffer;\n    this.contentBuffer = contentBuffer;\n\n    this.ctrl = new Int32Array(this.ctrlBuffer);\n    Atomics.store(this.ctrl, SyncContext.CTRL_OFFSET_STATE, SyncContext.STATE_WAITING_FOR_DATA);\n  }\n\n  static makeDefault(): SyncContext {\n    const ctrlBuffer = new SharedArrayBuffer(SyncContext.CTRL_BUFFER_LENGTH);\n    const contentBuffer = new SharedArrayBuffer(SyncContext.CONTENT_BUFFER_LENGTH);\n    return new SyncContext({ ctrlBuffer, contentBuffer });\n  }\n\n  makeSendable(): SendableSyncContext {\n    return {\n      ctrlBuffer: this.ctrlBuffer,\n      contentBuffer: this.contentBuffer,\n    };\n  }\n\n  sendError(reason: string): void {\n    const array = new TextEncoder().encode(reason);\n    this.sendInner(array, true);\n  }\n\n  send(array: Uint8Array): void {\n    this.sendInner(array, false);\n  }\n\n  private sendInner(array: Uint8Array, isError: boolean): void {\n    let position = 0;\n    let remainingBytes = array.byteLength;\n\n    Atomics.store(this.ctrl, SyncContext.CTRL_OFFSET_TOTAL_SIZE, remainingBytes);\n    const writeBuffer = new Uint8Array(this.contentBuffer);\n\n    while (remainingBytes > this.contentBuffer.byteLength) {\n      // Write a portion of the data, since the remaining size is larger than our buffer.\n      const temp = array.slice(position, position + writeBuffer.byteLength);\n      writeBuffer.set(temp);\n      position += writeBuffer.byteLength;\n      remainingBytes -= writeBuffer.byteLength;\n\n      Atomics.store(this.ctrl, SyncContext.CTRL_OFFSET_CURRENT_WRITE_SIZE, writeBuffer.byteLength);\n      Atomics.store(this.ctrl, SyncContext.CTRL_OFFSET_STATE, SyncContext.STATE_BUFFER_FULL);\n      Atomics.notify(this.ctrl, SyncContext.CTRL_OFFSET_STATE);\n      Atomics.wait(this.ctrl, SyncContext.CTRL_OFFSET_STATE, SyncContext.STATE_BUFFER_FULL);\n    }\n\n    // Write the remaining data, which will completely fit in our buffer.\n    const temp = array.slice(position);\n    writeBuffer.set(temp);\n\n    Atomics.store(this.ctrl, SyncContext.CTRL_OFFSET_CURRENT_WRITE_SIZE, remainingBytes);\n\n    if (isError) {\n      Atomics.store(this.ctrl, SyncContext.CTRL_OFFSET_STATE, SyncContext.STATE_TERMINATED_ERROR);\n    } else {\n      Atomics.store(this.ctrl, SyncContext.CTRL_OFFSET_STATE, SyncContext.STATE_DONE);\n    }\n    Atomics.notify(this.ctrl, SyncContext.CTRL_OFFSET_STATE);\n  }\n\n  receive(): Uint8Array {\n    Atomics.wait(this.ctrl, SyncContext.CTRL_OFFSET_STATE, SyncContext.STATE_WAITING_FOR_DATA);\n\n    const totalLength = Atomics.load(this.ctrl, SyncContext.CTRL_OFFSET_TOTAL_SIZE);\n    const output = new Uint8Array(totalLength);\n\n    const content = new Uint8Array(this.contentBuffer);\n    let writePosition = 0;\n\n    let currentState = Atomics.load(this.ctrl, SyncContext.CTRL_OFFSET_STATE);\n\n    while (currentState == SyncContext.STATE_BUFFER_FULL) {\n      // Receiving a portion of the full output.\n      const readLength = Atomics.load(this.ctrl, SyncContext.CTRL_OFFSET_CURRENT_WRITE_SIZE);\n      const temp = this.contentBuffer.slice(0, readLength);\n      output.set(new Uint8Array(temp), writePosition);\n      writePosition += readLength;\n\n      Atomics.store(this.ctrl, SyncContext.CTRL_OFFSET_STATE, SyncContext.STATE_WAITING_FOR_DATA);\n      Atomics.notify(this.ctrl, SyncContext.CTRL_OFFSET_STATE);\n      Atomics.wait(this.ctrl, SyncContext.CTRL_OFFSET_STATE, SyncContext.STATE_WAITING_FOR_DATA);\n\n      currentState = Atomics.load(this.ctrl, SyncContext.CTRL_OFFSET_STATE);\n    }\n\n    // Receiving the last of the output data.\n    const readLength = Atomics.load(this.ctrl, SyncContext.CTRL_OFFSET_CURRENT_WRITE_SIZE);\n    const temp = this.contentBuffer.slice(0, readLength);\n    output.set(new Uint8Array(temp), writePosition);\n\n    // Return the state to its initial value.\n    Atomics.store(this.ctrl, SyncContext.CTRL_OFFSET_STATE, SyncContext.STATE_WAITING_FOR_DATA);\n\n    if (currentState === SyncContext.STATE_DONE) {\n      return output;\n    } else if (currentState === SyncContext.STATE_TERMINATED_ERROR) {\n      throw new Error(new TextDecoder().decode(output));\n    } else {\n      throw new Error(`SyncContext: unexpected final state ${currentState}`);\n    }\n  }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { SyncContext } from './sync';\n\nonmessage = function fetchHandler(e: any): void {\n  const data = e.data;\n  console.log('Fetcher received channel data:', data);\n\n  const sync = new SyncContext(data.sync);\n\n  fetch(data.input, data.init)\n    .then((response) => {\n      console.log('worker fetch complete:', response.ok, response.status);\n      if (!response.ok) {\n        console.log('non-ok response:', response.status);\n        sync.sendError(`non-ok response: ${response.status}`);\n      } else {\n        response\n          .blob()\n          .then((blob) => blob.arrayBuffer())\n          .then((buffer) => {\n            sync.send(new Uint8Array(buffer));\n          })\n          .catch((reason) => {\n            console.log('blob error:', response.status);\n            sync.sendError(`blob error: ${reason}`);\n          });\n      }\n    })\n    .catch((reason) => {\n      console.log('fetch error:', reason);\n      sync.sendError(`fetch error: ${reason}`);\n    });\n}\n"],"names":[],"sourceRoot":""}