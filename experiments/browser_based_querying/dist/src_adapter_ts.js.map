{"version":3,"file":"src_adapter_ts.js","mappings":";;;;;;;;;;;;;;;;;;;;;AASA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAWA;AACA;AACA;AACA;AACA;AAJA;;AAOA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AAEA;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAKA;AAMA;AACA;AACA;AAEA;;AACA;AACA;AACA;;AAEA;AACA;AACA;AAFA;AAIA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAMA;AAKA;AACA;AACA;AACA;;AACA;AACA;AAAA;AAAA;AACA;;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAKA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;;AA7NA;AAgOA;AACA;AAEA;;;;;;;;;;;;;;;;;;;AC/WA;AACA;AACA;AACA;AADA;AAGA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AADA;AAGA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;;AADA;AAKA;AAAA;AAAA;AAAA;AACA;;AAEA;AACA;AACA;AAGA;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AADA;AAKA;AAAA;AAAA;AAAA;AACA;;AAEA;AACA;AACA;AAGA;;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACnEA;AAOA;AAGA;AACA;AAAA;AAAA;AACA;;AAEA;AAGA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AAEA;AAGA;AACA;AACA;AAxBA;AA2BA;AAKA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC1CA;AAMA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;;AAEA;AACA;AACA;AACA;AAFA;AAIA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;;;AAGA;AACA;AACA;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA1HA;;;;;;;;;;;;;;;;ACLA;AAOA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAGA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;AAGA;;;AAEA;AAEA;AACA;AAEA;AACA;AAEA;;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AAhDA;;;;;;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACLA;AAEA;AAEA;AAEA;;AAEA;AAAA;AAAA;;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;AAEA;AAEA;;AACA;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAFA;AAIA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AACA;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AACA;AACA;AACA;AACA;;AACA;AACA;;AAEA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;;;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA;AACA;AACA;;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;;AA1BA;AA4BA;AACA;;AACA;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;;AA/BA;AAiCA;AACA;;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;;AACA;AACA;;AArBA;AAuBA;AACA;;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;;AACA;AACA;;AArBA;AAuBA;AACA;;AACA;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;;AACA;AACA;;AA5BA;AA8BA;AACA;;AACA;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;;AACA;AACA;AACA;AACA;;;AACA;AACA;;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;;AApCA;AAsCA;AACA;;AACA;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;;AA7BA;AA+BA;AACA;;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;;AACA;AACA;;AArBA;AAuBA;AACA;;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;;AACA;AACA;;AArBA;AAuBA;AACA;;AACA;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;;AA/BA;AAiCA;AACA;;AACA;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;;AA1BA;AA4BA;AACA;;AACA;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AAjDA;AAmDA;AACA;;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AACA;;AACA;AACA;;AArBA;;AAwBA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;;AAEA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;;AACA;AACA;;AACA;AACA;;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AAAA;AACA;AACA;AACA;AAAA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACA;AAAA;AACA;AACA;AACA;AAAA;;AACA;AAAA;AACA;AACA;AACA;AAAA;;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAIA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AACA;;AAEA;AACA;AACA;;AAEA;AAEA;AAAA;AAAA;AAAA;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;ACv2BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;AACA;AACA;AACA;AACA;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AEbA;AACA;AACA;AACA","sources":["webpack://browser-based-querying/./src/adapter.ts","webpack://browser-based-querying/./src/hackernews.ts","webpack://browser-based-querying/./src/worker/client.ts","webpack://browser-based-querying/./src/worker/sync.ts","webpack://browser-based-querying/./src/worker/worker.ts","webpack://browser-based-querying/./www2/snippets/trustfall_wasm-7ec00372f6bf29da/inline0.js","webpack://browser-based-querying/./www2/trustfall_wasm.js","webpack://browser-based-querying/webpack/bootstrap","webpack://browser-based-querying/webpack/runtime/async module","webpack://browser-based-querying/webpack/runtime/define property getters","webpack://browser-based-querying/webpack/runtime/get javascript chunk filename","webpack://browser-based-querying/webpack/runtime/global","webpack://browser-based-querying/webpack/runtime/hasOwnProperty shorthand","webpack://browser-based-querying/webpack/runtime/make namespace object","webpack://browser-based-querying/webpack/runtime/publicPath","webpack://browser-based-querying/webpack/runtime/importScripts chunk loading","webpack://browser-based-querying/webpack/before-startup","webpack://browser-based-querying/webpack/startup","webpack://browser-based-querying/webpack/after-startup"],"sourcesContent":["import {\n  Adapter,\n  JsEdgeParameters,\n  JsContext,\n  ContextAndValue,\n  ContextAndNeighborsIterator,\n  ContextAndBool,\n} from '../www2/trustfall_wasm.js';\n\nimport { getTopItems, getLatestItems, materializeItem, materializeUser } from './hackernews';\nimport FetcherWorkerClient, { lazyFetchMap } from './worker/client';\nimport QueryWorker from './worker/worker';\n\n// TODO: This is a copy of schema.graphql, find a better way to include it.\nexport const schemaText = `\nschema {\n  query: RootSchemaQuery\n}\ndirective @filter(op: String!, value: [String!]) on FIELD | INLINE_FRAGMENT\ndirective @tag(name: String) on FIELD\ndirective @output(name: String) on FIELD\ndirective @optional on FIELD\ndirective @recurse(depth: Int!) on FIELD\ndirective @fold on FIELD\n\ntype RootSchemaQuery {\n  HackerNewsFrontPage: [HackerNewsItem!]!\n  HackerNewsTop(max: Int): [HackerNewsItem!]!\n  HackerNewsLatestStories(max: Int): [HackerNewsStory!]!\n  HackerNewsUser(name: String!): HackerNewsUser\n}\n\ninterface HackerNewsItem {\n  id: Int!\n  unixTime: Int!\n  ownUrl: String!\n}\n\ntype HackerNewsJob implements HackerNewsItem {\n  # properties from HackerNewsItem\n  id: Int!\n  unixTime: Int!\n  ownUrl: String!\n\n  # own properties\n  title: String!\n  score: Int!\n  url: String!\n\n  # edges\n  link: Webpage!\n}\n\ntype HackerNewsStory implements HackerNewsItem {\n  # properties from HackerNewsItem\n  id: Int!\n  unixTime: Int!\n  ownUrl: String!\n\n  # own properties\n  byUsername: String!\n  score: Int!\n  text: String\n  title: String!\n  url: String\n  commentsCount: Int!\n\n  # edges\n  byUser: HackerNewsUser!\n  comment: [HackerNewsComment!]\n  link: Webpage\n}\n\ntype HackerNewsComment implements HackerNewsItem {\n  # properties from HackerNewsItem\n  id: Int!\n  unixTime: Int!\n  ownUrl: String!\n\n  # own properties\n  text: String!\n  byUsername: String!\n\n  # edges\n  byUser: HackerNewsUser!\n  reply: [HackerNewsComment!]\n  parent: HackerNewsItem!  # either a parent comment or the story being commented on\n\n  # not implemented yet\n  # topmostAncestor: HackerNewsItem!  # the ultimate ancestor of this item: a story or job\n}\n\ntype HackerNewsUser {\n  id: String!\n  karma: Int!\n  about: String\n  unixCreatedAt: Int!\n\n  # The HackerNews API treats submissions of comments and stories the same way.\n  # The way to get only a user's submitted stories is to use this edge then\n  # apply a type coercion on the \\`HackerNewsItem\\` vertex on edge endpoint:\n  # \\`...on HackerNewsStory\\`\n  submitted: [HackerNewsItem!]\n}\n\ninterface Webpage {\n  url: String!\n}\n`;\n\nconsole.log('Schema loaded.');\n\ntype Vertex = any;\n\nconst HNItemFieldMappings: Record<string, string> = {\n  id: 'id',\n  unixTime: 'time',\n  title: 'title',\n  score: 'score',\n  url: 'url',\n  byUsername: 'by',\n  text: 'text',\n  commentsCount: 'descendants',\n};\n\nconst HNUserFieldMappings: Record<string, string> = {\n  id: 'id',\n  karma: 'karma',\n  about: 'about',\n  unixCreatedAt: 'created',\n};\n\nfunction* limitIterator<T>(iter: IterableIterator<T>, limit: number): IterableIterator<T> {\n  let count = 0;\n  for (const item of iter) {\n    yield item;\n    count += 1;\n    if (count == limit) {\n      break;\n    }\n  }\n}\n\nexport class MyAdapter implements Adapter<Vertex> {\n  client: FetcherWorkerClient\n\n  constructor(client: FetcherWorkerClient) {\n    this.client = client;\n  }\n\n  *getStartingTokens(edge: string, parameters: JsEdgeParameters): IterableIterator<Vertex> {\n    if (edge === 'HackerNewsFrontPage') {\n      return limitIterator(getTopItems(this.client), 30);\n    } else if (edge === 'HackerNewsTop') {\n      const limit = parameters['max'];\n      const iter = getTopItems(this.client);\n      if (limit == undefined) {\n        yield* iter;\n      } else {\n        yield* limitIterator(iter, limit as number);\n      }\n    } else if (edge === 'HackerNewsLatestStories') {\n      const limit = parameters['max'];\n      const iter = getLatestItems(this.client);\n      if (limit == undefined) {\n        yield* iter;\n      } else {\n        yield* limitIterator(iter, limit as number);\n      }\n    } else if (edge === 'HackerNewsUser') {\n      const username = parameters['name'];\n      if (username == undefined) {\n        throw new Error(`No username given: ${edge} ${parameters}`);\n      }\n\n      const user = materializeUser(this.client, username as string);\n      if (user != null) {\n        yield user;\n      }\n    } else {\n      throw new Error(`Unexpected edge ${edge} with params ${parameters}`);\n    }\n  }\n\n  *projectProperty(\n    data_contexts: IterableIterator<JsContext<Vertex>>,\n    current_type_name: string,\n    field_name: string\n  ): IterableIterator<ContextAndValue> {\n    if (\n      current_type_name === 'HackerNewsItem' ||\n      current_type_name === 'HackerNewsStory' ||\n      current_type_name === 'HackerNewsJob' ||\n      current_type_name === 'HackerNewsComment'\n    ) {\n      if (field_name == 'ownUrl') {\n        for (const ctx of data_contexts) {\n          const vertex = ctx.currentToken;\n\n          let value = null;\n          if (vertex) {\n            value = `https://news.ycombinator.com/item?id=${vertex.id}`;\n          }\n\n          yield {\n            localId: ctx.localId,\n            value: value,\n          };\n        }\n      } else {\n        const fieldKey = HNItemFieldMappings[field_name];\n        if (fieldKey == undefined) {\n          throw new Error(`Unexpected property for type ${current_type_name}: ${field_name}`);\n        }\n\n        for (const ctx of data_contexts) {\n          const vertex = ctx.currentToken;\n\n          yield {\n            localId: ctx.localId,\n            value: vertex ? vertex[fieldKey] || null : null,\n          };\n        }\n      }\n    } else if (current_type_name === 'HackerNewsUser') {\n      const fieldKey = HNUserFieldMappings[field_name];\n      if (fieldKey == undefined) {\n        throw new Error(`Unexpected property for type ${current_type_name}: ${field_name}`);\n      }\n\n      for (const ctx of data_contexts) {\n        const vertex = ctx.currentToken;\n        yield {\n          localId: ctx.localId,\n          value: vertex ? vertex[fieldKey] || null : null,\n        };\n      }\n    } else if (current_type_name === 'Webpage') {\n      if (field_name === 'url') {\n        for (const ctx of data_contexts) {\n          const vertex = ctx.currentToken;\n          yield {\n            localId: ctx.localId,\n            value: vertex?.url || null,\n          };\n        }\n      } else {\n        throw new Error(`Unexpected property: ${current_type_name} ${field_name}`);\n      }\n    } else {\n      throw new Error(`Unexpected type+property for type ${current_type_name}: ${field_name}`);\n    }\n  }\n\n  *projectNeighbors(\n    data_contexts: IterableIterator<JsContext<Vertex>>,\n    current_type_name: string,\n    edge_name: string,\n    parameters: JsEdgeParameters\n  ): IterableIterator<ContextAndNeighborsIterator<Vertex>> {\n    if (\n      current_type_name === 'HackerNewsStory' ||\n      current_type_name === 'HackerNewsJob' ||\n      current_type_name === 'HackerNewsComment'\n    ) {\n      if (edge_name === 'link') {\n        for (const ctx of data_contexts) {\n          const vertex = ctx.currentToken;\n          let neighbors: Vertex[] = [];\n          if (vertex) {\n            neighbors = [{ url: vertex.url }];\n          }\n          yield {\n            localId: ctx.localId,\n            neighbors: neighbors[Symbol.iterator](),\n          };\n        }\n      } else if (edge_name === 'byUser') {\n        for (const ctx of data_contexts) {\n          const vertex = ctx.currentToken;\n          if (vertex) {\n            yield {\n              localId: ctx.localId,\n              neighbors: lazyFetchMap(this.client, [vertex.by], materializeUser),\n            };\n          } else {\n            yield {\n              localId: ctx.localId,\n              neighbors: [][Symbol.iterator](),\n            };\n          }\n        }\n      } else if (edge_name === 'comment' || edge_name === 'reply') {\n        for (const ctx of data_contexts) {\n          const vertex = ctx.currentToken;\n          yield {\n            localId: ctx.localId,\n            neighbors: lazyFetchMap(this.client, vertex?.kids, materializeItem),\n          };\n        }\n      } else if (edge_name === 'parent') {\n        for (const ctx of data_contexts) {\n          const vertex = ctx.currentToken;\n          const parent = vertex?.parent;\n          if (parent) {\n            yield {\n              localId: ctx.localId,\n              neighbors: lazyFetchMap(this.client, [parent], materializeItem),\n            };\n          } else {\n            yield {\n              localId: ctx.localId,\n              neighbors: [][Symbol.iterator](),\n            };\n          }\n        }\n      } else {\n        throw new Error(`Not implemented: ${current_type_name} ${edge_name} ${parameters}`);\n      }\n    } else if (current_type_name === 'HackerNewsUser') {\n      if (edge_name === 'submitted') {\n        for (const ctx of data_contexts) {\n          const vertex = ctx.currentToken;\n          const submitted = vertex?.submitted;\n          yield {\n            localId: ctx.localId,\n            neighbors: lazyFetchMap(this.client, submitted, materializeItem),\n          };\n        }\n      } else {\n        throw new Error(`Not implemented: ${current_type_name} ${edge_name} ${parameters}`);\n      }\n    } else {\n      throw new Error(`Not implemented: ${current_type_name} ${edge_name} ${parameters}`);\n    }\n  }\n\n  *canCoerceToType(\n    data_contexts: IterableIterator<JsContext<Vertex>>,\n    current_type_name: string,\n    coerce_to_type_name: string\n  ): IterableIterator<ContextAndBool> {\n    if (current_type_name === 'HackerNewsItem') {\n      let targetType;\n      if (coerce_to_type_name === 'HackerNewsStory') {\n        targetType = 'story';\n      } else if (coerce_to_type_name === 'HackerNewsJob') {\n        targetType = 'job';\n      } else if (coerce_to_type_name === 'HackerNewsComment') {\n        targetType = 'comment';\n      } else {\n        throw new Error(`Unexpected coercion from ${current_type_name} to ${coerce_to_type_name}`);\n      }\n\n      for (const ctx of data_contexts) {\n        const vertex = ctx.currentToken;\n        yield {\n          localId: ctx.localId,\n          value: vertex?.type === targetType,\n        };\n      }\n    } else {\n      throw new Error(`Unexpected coercion from ${current_type_name} to ${coerce_to_type_name}`);\n    }\n  }\n}\n\nconst adapter = new MyAdapter(new FetcherWorkerClient())\nconst queryWorker = new QueryWorker(adapter, schemaText);\n\nonmessage = queryWorker.dispatch;\n","import Client from './worker/client'\n\n\nexport function materializeItem(client: Client, itemId: number): any {\n  const url = `https://hacker-news.firebaseio.com/v0/item/${itemId}.json`;\n  const fetchOptions = {\n    method: 'GET',\n  };\n  const item = client.getJSON<any>({url, fetchOptions});\n  console.log('materialized item:', item);\n\n  return item;\n}\n\nexport function materializeUser(client: Client, username: string): any {\n  const url = `https://hacker-news.firebaseio.com/v0/user/${username}.json`;\n  const fetchOptions = {\n    method: 'GET',\n  };\n  const user = client.getJSON<any>({url, fetchOptions});\n  console.log('materialized user:', user);\n\n  return user;\n}\n\nexport function* getTopItems(client: Client): any {\n  const url = 'https://hacker-news.firebaseio.com/v0/topstories.json';\n  const fetchOptions = {\n    method: 'GET',\n    // \"credentials\": \"omit\",\n  };\n\n  const storyIds = client.getJSON<any[]>({url, fetchOptions})\n  console.log('storyIds=', storyIds);\n\n  for (const id of storyIds) {\n    const item = materializeItem(client, id);\n    const itemType = item['type'];\n\n    // Ignore polls. They are very rarely made on HackerNews,\n    // and they are not supported in our query schema.\n    if (itemType === 'story' || itemType === 'job') {\n      yield item;\n    }\n  }\n}\n\nexport function* getLatestItems(client: Client): any {\n  const url = 'https://hacker-news.firebaseio.com/v0/newstories.json';\n  const fetchOptions = {\n    method: 'GET',\n    // \"credentials\": \"omit\",\n  };\n\n  const storyIds = client.getJSON<any[]>({url, fetchOptions});\n  console.log('storyIds=', storyIds);\n\n  for (const id of storyIds) {\n    const item = materializeItem(client, id);\n    const itemType = item['type'];\n\n    // Ignore polls. They are very rarely made on HackerNews,\n    // and they are not supported in our query schema.\n    if (itemType === 'story' || itemType === 'job') {\n      yield item;\n    }\n  }\n}\n","import { SyncContext } from './sync';\n\ninterface RequestMessage {\n  url: URL | string,\n  fetchOptions: RequestInit,\n}\n\nexport default class FetcherWorkerClient {\n  worker: Worker\n\n  constructor() {\n    this.worker = new Worker(new URL('./fetcher', import.meta.url), { type: 'module' }); \n  }\n\n  get = (\n    message: RequestMessage,\n  ): string => {\n    const sync = SyncContext.makeDefault();\n    this.worker.postMessage({\n      sync: sync.makeSendable(),\n      input: message.url,\n      init: message.fetchOptions,\n    });\n    return new TextDecoder().decode(sync.receive());\n  }\n\n  getJSON = <T = unknown>(\n    message: RequestMessage,\n  ): T => {\n    const result = this.get(message)\n    return JSON.parse(result)\n  }\n}\n\nexport function* lazyFetchMap<InT, OutT>(\n  client: FetcherWorkerClient,\n  inputs: Array<InT> | null,\n  func: (client: FetcherWorkerClient, arg: InT) => OutT\n): IterableIterator<OutT> {\n  if (inputs) {\n    for (const input of inputs) {\n      const result = func(client, input);\n      if (result != null) {\n        yield result;\n      }\n    }\n  }\n}\n","export interface SendableSyncContext {\n  contentBuffer: SharedArrayBuffer;\n  ctrlBuffer: SharedArrayBuffer;\n}\n\nexport class SyncContext {\n  contentBuffer: SharedArrayBuffer;\n  ctrlBuffer: SharedArrayBuffer;\n\n  ctrl: Int32Array;\n\n  static CTRL_BUFFER_LENGTH = 12;\n  static CONTENT_BUFFER_LENGTH = 4096;\n\n  static CTRL_OFFSET_STATE = 0;\n  static CTRL_OFFSET_CURRENT_WRITE_SIZE = 1;\n  static CTRL_OFFSET_TOTAL_SIZE = 2;\n\n  static STATE_WAITING_FOR_DATA = 128;\n  static STATE_DONE = 1;\n  static STATE_BUFFER_FULL = 2;\n  static STATE_TERMINATED_ERROR = 3;\n\n  constructor({ ctrlBuffer, contentBuffer }: SendableSyncContext) {\n    this.ctrlBuffer = ctrlBuffer;\n    this.contentBuffer = contentBuffer;\n\n    this.ctrl = new Int32Array(this.ctrlBuffer);\n    Atomics.store(this.ctrl, SyncContext.CTRL_OFFSET_STATE, SyncContext.STATE_WAITING_FOR_DATA);\n  }\n\n  static makeDefault(): SyncContext {\n    const ctrlBuffer = new SharedArrayBuffer(SyncContext.CTRL_BUFFER_LENGTH);\n    const contentBuffer = new SharedArrayBuffer(SyncContext.CONTENT_BUFFER_LENGTH);\n    return new SyncContext({ ctrlBuffer, contentBuffer });\n  }\n\n  makeSendable(): SendableSyncContext {\n    return {\n      ctrlBuffer: this.ctrlBuffer,\n      contentBuffer: this.contentBuffer,\n    };\n  }\n\n  sendError(reason: string): void {\n    const array = new TextEncoder().encode(reason);\n    this.sendInner(array, true);\n  }\n\n  send(array: Uint8Array): void {\n    this.sendInner(array, false);\n  }\n\n  private sendInner(array: Uint8Array, isError: boolean): void {\n    let position = 0;\n    let remainingBytes = array.byteLength;\n\n    Atomics.store(this.ctrl, SyncContext.CTRL_OFFSET_TOTAL_SIZE, remainingBytes);\n    const writeBuffer = new Uint8Array(this.contentBuffer);\n\n    while (remainingBytes > this.contentBuffer.byteLength) {\n      // Write a portion of the data, since the remaining size is larger than our buffer.\n      const temp = array.slice(position, position + writeBuffer.byteLength);\n      writeBuffer.set(temp);\n      position += writeBuffer.byteLength;\n      remainingBytes -= writeBuffer.byteLength;\n\n      Atomics.store(this.ctrl, SyncContext.CTRL_OFFSET_CURRENT_WRITE_SIZE, writeBuffer.byteLength);\n      Atomics.store(this.ctrl, SyncContext.CTRL_OFFSET_STATE, SyncContext.STATE_BUFFER_FULL);\n      Atomics.notify(this.ctrl, SyncContext.CTRL_OFFSET_STATE);\n      Atomics.wait(this.ctrl, SyncContext.CTRL_OFFSET_STATE, SyncContext.STATE_BUFFER_FULL);\n    }\n\n    // Write the remaining data, which will completely fit in our buffer.\n    const temp = array.slice(position);\n    writeBuffer.set(temp);\n\n    Atomics.store(this.ctrl, SyncContext.CTRL_OFFSET_CURRENT_WRITE_SIZE, remainingBytes);\n\n    if (isError) {\n      Atomics.store(this.ctrl, SyncContext.CTRL_OFFSET_STATE, SyncContext.STATE_TERMINATED_ERROR);\n    } else {\n      Atomics.store(this.ctrl, SyncContext.CTRL_OFFSET_STATE, SyncContext.STATE_DONE);\n    }\n    Atomics.notify(this.ctrl, SyncContext.CTRL_OFFSET_STATE);\n  }\n\n  receive(): Uint8Array {\n    Atomics.wait(this.ctrl, SyncContext.CTRL_OFFSET_STATE, SyncContext.STATE_WAITING_FOR_DATA);\n\n    const totalLength = Atomics.load(this.ctrl, SyncContext.CTRL_OFFSET_TOTAL_SIZE);\n    const output = new Uint8Array(totalLength);\n\n    const content = new Uint8Array(this.contentBuffer);\n    let writePosition = 0;\n\n    let currentState = Atomics.load(this.ctrl, SyncContext.CTRL_OFFSET_STATE);\n\n    while (currentState == SyncContext.STATE_BUFFER_FULL) {\n      // Receiving a portion of the full output.\n      const readLength = Atomics.load(this.ctrl, SyncContext.CTRL_OFFSET_CURRENT_WRITE_SIZE);\n      const temp = this.contentBuffer.slice(0, readLength);\n      output.set(new Uint8Array(temp), writePosition);\n      writePosition += readLength;\n\n      Atomics.store(this.ctrl, SyncContext.CTRL_OFFSET_STATE, SyncContext.STATE_WAITING_FOR_DATA);\n      Atomics.notify(this.ctrl, SyncContext.CTRL_OFFSET_STATE);\n      Atomics.wait(this.ctrl, SyncContext.CTRL_OFFSET_STATE, SyncContext.STATE_WAITING_FOR_DATA);\n\n      currentState = Atomics.load(this.ctrl, SyncContext.CTRL_OFFSET_STATE);\n    }\n\n    // Receiving the last of the output data.\n    const readLength = Atomics.load(this.ctrl, SyncContext.CTRL_OFFSET_CURRENT_WRITE_SIZE);\n    const temp = this.contentBuffer.slice(0, readLength);\n    output.set(new Uint8Array(temp), writePosition);\n\n    // Return the state to its initial value.\n    Atomics.store(this.ctrl, SyncContext.CTRL_OFFSET_STATE, SyncContext.STATE_WAITING_FOR_DATA);\n\n    if (currentState === SyncContext.STATE_DONE) {\n      return output;\n    } else if (currentState === SyncContext.STATE_TERMINATED_ERROR) {\n      throw new Error(new TextDecoder().decode(output));\n    } else {\n      throw new Error(`SyncContext: unexpected final state ${currentState}`);\n    }\n  }\n}\n","import init, {\n  Adapter,\n  Schema,\n  initialize,\n  executeQuery,\n} from '../../www2/trustfall_wasm.js';\n\nconsole.log('running wasm init...');\nawait init();\nconsole.log('wasm init complete');\n\nconsole.log('Query system init...');\ninitialize();\nconsole.log('Query system initialized');\n\npostMessage('ready');\n\nexport default class QueryWorker<V> {\n  adapter: Adapter<V>\n  schema: Schema\n  currentResultIter: Iterator<any> | undefined = undefined\n\n  constructor(adapter: Adapter<V>, schemaText: string) {\n    this.adapter = adapter;\n    this.schema = Schema.parse(schemaText);\n  }\n\n  performQuery = (query: string, args: any): any => {\n    if (query == null || query == undefined) {\n      throw new Error(`Cannot perform null/undef query.`);\n    }\n    if (args == null || args == undefined) {\n      throw new Error(`Cannot perform query with null/undef args.`);\n    }\n\n    // TODO: figure out why the schema object gets set to null\n    //       as part of the executeQuery() call.\n\n    const resultIter = executeQuery(this.schema, this.adapter, query, args);\n\n    return resultIter;\n  }\n\n  dispatch = (event: MessageEvent): void => {\n    const payload = event.data;\n\n    console.log('Adapter received message:', payload);\n    if (payload.op === 'query') {\n      this.currentResultIter = this.performQuery(payload.query, payload.args);\n      payload.op = 'next';\n    }\n\n    if (payload.op === 'next') {\n      if (this.currentResultIter === undefined) {\n        throw new Error('No query results to iterate')\n      }\n      const rawResult = this.currentResultIter.next();\n      const result = {\n        done: rawResult.done,\n        value: rawResult.value,\n      };\n      console.log('Adapter posting:', result);\n      postMessage(result);\n      return;\n    }\n  }\n}\n","\n    export function iterify(obj) {\n        obj[Symbol.iterator] = function () {\n            return this;\n        };\n    }\n","import { iterify } from './snippets/trustfall_wasm-7ec00372f6bf29da/inline0.js';\n\nlet wasm;\n\nconst heap = new Array(32).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nfunction getObject(idx) { return heap[idx]; }\n\nlet heap_next = heap.length;\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nfunction dropObject(idx) {\n    if (idx < 36) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nconst cachedTextDecoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nlet cachedUint8Memory0;\nfunction getUint8Memory0() {\n    if (cachedUint8Memory0.byteLength === 0) {\n        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8Memory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nconst cachedTextEncoder = new TextEncoder('utf-8');\n\nconst encodeString = (typeof cachedTextEncoder.encodeInto === 'function'\n    ? function (arg, view) {\n    return cachedTextEncoder.encodeInto(arg, view);\n}\n    : function (arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n});\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length);\n        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len);\n\n    const mem = getUint8Memory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3);\n        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n\n        offset += ret.written;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nlet cachedInt32Memory0;\nfunction getInt32Memory0() {\n    if (cachedInt32Memory0.byteLength === 0) {\n        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachedInt32Memory0;\n}\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nlet cachedFloat64Memory0;\nfunction getFloat64Memory0() {\n    if (cachedFloat64Memory0.byteLength === 0) {\n        cachedFloat64Memory0 = new Float64Array(wasm.memory.buffer);\n    }\n    return cachedFloat64Memory0;\n}\n\nfunction debugString(val) {\n    // primitive types\n    const type = typeof val;\n    if (type == 'number' || type == 'boolean' || val == null) {\n        return  `${val}`;\n    }\n    if (type == 'string') {\n        return `\"${val}\"`;\n    }\n    if (type == 'symbol') {\n        const description = val.description;\n        if (description == null) {\n            return 'Symbol';\n        } else {\n            return `Symbol(${description})`;\n        }\n    }\n    if (type == 'function') {\n        const name = val.name;\n        if (typeof name == 'string' && name.length > 0) {\n            return `Function(${name})`;\n        } else {\n            return 'Function';\n        }\n    }\n    // objects\n    if (Array.isArray(val)) {\n        const length = val.length;\n        let debug = '[';\n        if (length > 0) {\n            debug += debugString(val[0]);\n        }\n        for(let i = 1; i < length; i++) {\n            debug += ', ' + debugString(val[i]);\n        }\n        debug += ']';\n        return debug;\n    }\n    // Test for built-in\n    const builtInMatches = /\\[object ([^\\]]+)\\]/.exec(toString.call(val));\n    let className;\n    if (builtInMatches.length > 1) {\n        className = builtInMatches[1];\n    } else {\n        // Failed to match the standard '[object ClassName]'\n        return toString.call(val);\n    }\n    if (className == 'Object') {\n        // we're a user defined class or Object\n        // JSON.stringify avoids problems with cycles, and is generally much\n        // easier than looping through ownProperties of `val`.\n        try {\n            return 'Object(' + JSON.stringify(val) + ')';\n        } catch (_) {\n            return 'Object';\n        }\n    }\n    // errors\n    if (val instanceof Error) {\n        return `${val.name}: ${val.message}\\n${val.stack}`;\n    }\n    // TODO we could test for more things here, like `Set`s and `Map`s.\n    return className;\n}\n\nfunction _assertClass(instance, klass) {\n    if (!(instance instanceof klass)) {\n        throw new Error(`expected instance of ${klass.name}`);\n    }\n    return instance.ptr;\n}\n/**\n* @param {Schema} schema\n* @param {any} adapter\n* @param {string} query\n* @param {any} args\n* @returns {QueryResultIterator}\n*/\nexport function executeQuery(schema, adapter, query, args) {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        _assertClass(schema, Schema);\n        var ptr0 = schema.ptr;\n        schema.ptr = 0;\n        const ptr1 = passStringToWasm0(query, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        wasm.executeQuery(retptr, ptr0, addHeapObject(adapter), ptr1, len1, addHeapObject(args));\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        var r2 = getInt32Memory0()[retptr / 4 + 2];\n        if (r2) {\n            throw takeObject(r1);\n        }\n        return QueryResultIterator.__wrap(r0);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\n/**\n*/\nexport function initialize() {\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm.initialize(retptr);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        if (r1) {\n            throw takeObject(r0);\n        }\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n    }\n}\n\nfunction handleError(f, args) {\n    try {\n        return f.apply(this, args);\n    } catch (e) {\n        wasm.__wbindgen_exn_store(addHeapObject(e));\n    }\n}\n/**\n*/\nexport class ContextIterator {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ContextIterator.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_contextiterator_free(ptr);\n    }\n    /**\n    * @returns {ContextIteratorItem}\n    */\n    next() {\n        const ret = wasm.contextiterator_next(this.ptr);\n        return ContextIteratorItem.__wrap(ret);\n    }\n}\n/**\n*/\nexport class ContextIteratorItem {\n\n    static __wrap(ptr) {\n        const obj = Object.create(ContextIteratorItem.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_contextiteratoritem_free(ptr);\n    }\n    /**\n    */\n    get done() {\n        const ret = wasm.contextiteratoritem_done(this.ptr);\n        return ret !== 0;\n    }\n    /**\n    */\n    get value() {\n        const ret = wasm.contextiteratoritem_value(this.ptr);\n        return ret === 0 ? undefined : JsContext.__wrap(ret);\n    }\n}\n/**\n*/\nexport class FrontendError {\n\n    toJSON() {\n        return {\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_frontenderror_free(ptr);\n    }\n}\n/**\n*/\nexport class InvalidIRQueryError {\n\n    toJSON() {\n        return {\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_invalidirqueryerror_free(ptr);\n    }\n}\n/**\n*/\nexport class InvalidSchemaError {\n\n    static __wrap(ptr) {\n        const obj = Object.create(InvalidSchemaError.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    toJSON() {\n        return {\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_invalidschemaerror_free(ptr);\n    }\n}\n/**\n*/\nexport class JsContext {\n\n    static __wrap(ptr) {\n        const obj = Object.create(JsContext.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_jscontext_free(ptr);\n    }\n    /**\n    */\n    get localId() {\n        const ret = wasm.__wbg_get_jscontext_localId(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    */\n    set localId(arg0) {\n        wasm.__wbg_set_jscontext_localId(this.ptr, arg0);\n    }\n    /**\n    */\n    get currentToken() {\n        const ret = wasm.jscontext_currentToken(this.ptr);\n        return takeObject(ret);\n    }\n}\n/**\n*/\nexport class JsEdgeParameters {\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_jsedgeparameters_free(ptr);\n    }\n    /**\n    * @param {string} name\n    * @returns {any}\n    */\n    get(name) {\n        const ptr0 = passStringToWasm0(name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.jsedgeparameters_get(this.ptr, ptr0, len0);\n        return takeObject(ret);\n    }\n    /**\n    * @returns {any}\n    */\n    into_js_dict() {\n        const ret = wasm.jsedgeparameters_into_js_dict(this.ptr);\n        return takeObject(ret);\n    }\n}\n/**\n*/\nexport class ParseError {\n\n    toJSON() {\n        return {\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_parseerror_free(ptr);\n    }\n}\n/**\n*/\nexport class QueryArgumentsError {\n\n    toJSON() {\n        return {\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_queryargumentserror_free(ptr);\n    }\n}\n/**\n*/\nexport class QueryResultItem {\n\n    static __wrap(ptr) {\n        const obj = Object.create(QueryResultItem.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_queryresultitem_free(ptr);\n    }\n    /**\n    */\n    get done() {\n        const ret = wasm.queryresultitem_done(this.ptr);\n        return ret !== 0;\n    }\n    /**\n    */\n    get value() {\n        const ret = wasm.queryresultitem_value(this.ptr);\n        return takeObject(ret);\n    }\n}\n/**\n*/\nexport class QueryResultIterator {\n\n    static __wrap(ptr) {\n        const obj = Object.create(QueryResultIterator.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_queryresultiterator_free(ptr);\n    }\n    /**\n    * @returns {QueryResultItem}\n    */\n    next() {\n        const ret = wasm.queryresultiterator_next(this.ptr);\n        return QueryResultItem.__wrap(ret);\n    }\n}\n/**\n*/\nexport class Schema {\n\n    static __wrap(ptr) {\n        const obj = Object.create(Schema.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    toJSON() {\n        return {\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_schema_free(ptr);\n    }\n    /**\n    * @param {string} input\n    * @returns {Schema}\n    */\n    static parse(input) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            const ptr0 = passStringToWasm0(input, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n            const len0 = WASM_VECTOR_LEN;\n            wasm.schema_parse(retptr, ptr0, len0);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            var r2 = getInt32Memory0()[retptr / 4 + 2];\n            if (r2) {\n                throw takeObject(r1);\n            }\n            return Schema.__wrap(r0);\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nexport class ValidationError {\n\n    toJSON() {\n        return {\n        };\n    }\n\n    toString() {\n        return JSON.stringify(this);\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_validationerror_free(ptr);\n    }\n}\n\nasync function load(module, imports) {\n    if (typeof Response === 'function' && module instanceof Response) {\n        if (typeof WebAssembly.instantiateStreaming === 'function') {\n            try {\n                return await WebAssembly.instantiateStreaming(module, imports);\n\n            } catch (e) {\n                if (module.headers.get('Content-Type') != 'application/wasm') {\n                    console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n\", e);\n\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        const bytes = await module.arrayBuffer();\n        return await WebAssembly.instantiate(bytes, imports);\n\n    } else {\n        const instance = await WebAssembly.instantiate(module, imports);\n\n        if (instance instanceof WebAssembly.Instance) {\n            return { instance, module };\n\n        } else {\n            return instance;\n        }\n    }\n}\n\nfunction getImports() {\n    const imports = {};\n    imports.wbg = {};\n    imports.wbg.__wbindgen_object_clone_ref = function(arg0) {\n        const ret = getObject(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_object_drop_ref = function(arg0) {\n        takeObject(arg0);\n    };\n    imports.wbg.__wbindgen_string_new = function(arg0, arg1) {\n        const ret = getStringFromWasm0(arg0, arg1);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_json_parse = function(arg0, arg1) {\n        const ret = JSON.parse(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_json_serialize = function(arg0, arg1) {\n        const obj = getObject(arg1);\n        const ret = JSON.stringify(obj === undefined ? null : obj);\n        const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len0;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n    };\n    imports.wbg.__wbg_contextiterator_new = function(arg0) {\n        const ret = ContextIterator.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_queryresultiterator_new = function(arg0) {\n        const ret = QueryResultIterator.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_invalidschemaerror_new = function(arg0) {\n        const ret = InvalidSchemaError.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_number_get = function(arg0, arg1) {\n        const obj = getObject(arg1);\n        const ret = typeof(obj) === 'number' ? obj : undefined;\n        getFloat64Memory0()[arg0 / 8 + 1] = isLikeNone(ret) ? 0 : ret;\n        getInt32Memory0()[arg0 / 4 + 0] = !isLikeNone(ret);\n    };\n    imports.wbg.__wbg_getStartingTokens_4311e8fbd98a7147 = function(arg0, arg1, arg2, arg3) {\n        const ret = getObject(arg0).getStartingTokens(getStringFromWasm0(arg1, arg2), takeObject(arg3));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_projectProperty_34fe60840b971b0e = function(arg0, arg1, arg2, arg3, arg4, arg5) {\n        const ret = getObject(arg0).projectProperty(ContextIterator.__wrap(arg1), getStringFromWasm0(arg2, arg3), getStringFromWasm0(arg4, arg5));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_projectNeighbors_0e7ab848b1eee864 = function(arg0, arg1, arg2, arg3, arg4, arg5, arg6) {\n        const ret = getObject(arg0).projectNeighbors(ContextIterator.__wrap(arg1), getStringFromWasm0(arg2, arg3), getStringFromWasm0(arg4, arg5), takeObject(arg6));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_canCoerceToType_2b6b6ecc7b0ef574 = function(arg0, arg1, arg2, arg3, arg4, arg5) {\n        const ret = getObject(arg0).canCoerceToType(ContextIterator.__wrap(arg1), getStringFromWasm0(arg2, arg3), getStringFromWasm0(arg4, arg5));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_iterify_4e224c3222b26363 = function(arg0) {\n        iterify(getObject(arg0));\n    };\n    imports.wbg.__wbg_new_693216e109162396 = function() {\n        const ret = new Error();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_stack_0ddaca5d1abfb52f = function(arg0, arg1) {\n        const ret = getObject(arg1).stack;\n        const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len0;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n    };\n    imports.wbg.__wbg_error_09919627ac0992f5 = function(arg0, arg1) {\n        try {\n            console.error(getStringFromWasm0(arg0, arg1));\n        } finally {\n            wasm.__wbindgen_free(arg0, arg1);\n        }\n    };\n    imports.wbg.__wbindgen_is_function = function(arg0) {\n        const ret = typeof(getObject(arg0)) === 'function';\n        return ret;\n    };\n    imports.wbg.__wbindgen_is_object = function(arg0) {\n        const val = getObject(arg0);\n        const ret = typeof(val) === 'object' && val !== null;\n        return ret;\n    };\n    imports.wbg.__wbg_next_0e1ee6203bc0f8ed = function(arg0) {\n        const ret = getObject(arg0).next;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_next_9ef803116340cdc1 = function() { return handleError(function (arg0) {\n        const ret = getObject(arg0).next();\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_done_2a1e30464aae6a4d = function(arg0) {\n        const ret = getObject(arg0).done;\n        return ret;\n    };\n    imports.wbg.__wbg_value_a495c29471c31da6 = function(arg0) {\n        const ret = getObject(arg0).value;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_iterator_6ac6eb1e020f18e3 = function() {\n        const ret = Symbol.iterator;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_get_89247d3aeaa38cc5 = function() { return handleError(function (arg0, arg1) {\n        const ret = Reflect.get(getObject(arg0), getObject(arg1));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_call_4573f605ca4b5f10 = function() { return handleError(function (arg0, arg1) {\n        const ret = getObject(arg0).call(getObject(arg1));\n        return addHeapObject(ret);\n    }, arguments) };\n    imports.wbg.__wbg_getPrototypeOf_61762819d7424c07 = function(arg0) {\n        const ret = Object.getPrototypeOf(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_debug_string = function(arg0, arg1) {\n        const ret = debugString(getObject(arg1));\n        const ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len0 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len0;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n    };\n    imports.wbg.__wbindgen_throw = function(arg0, arg1) {\n        throw new Error(getStringFromWasm0(arg0, arg1));\n    };\n\n    return imports;\n}\n\nfunction initMemory(imports, maybe_memory) {\n\n}\n\nfunction finalizeInit(instance, module) {\n    wasm = instance.exports;\n    init.__wbindgen_wasm_module = module;\n    cachedFloat64Memory0 = new Float64Array(wasm.memory.buffer);\n    cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n\n\n    return wasm;\n}\n\nfunction initSync(bytes) {\n    const imports = getImports();\n\n    initMemory(imports);\n\n    const module = new WebAssembly.Module(bytes);\n    const instance = new WebAssembly.Instance(module, imports);\n\n    return finalizeInit(instance, module);\n}\n\nasync function init(input) {\n    if (typeof input === 'undefined') {\n        input = new URL('trustfall_wasm_bg.wasm', import.meta.url);\n    }\n    const imports = getImports();\n\n    if (typeof input === 'string' || (typeof Request === 'function' && input instanceof Request) || (typeof URL === 'function' && input instanceof URL)) {\n        input = fetch(input);\n    }\n\n    initMemory(imports);\n\n    const { instance, module } = await load(await input, imports);\n\n    return finalizeInit(instance, module);\n}\n\nexport { initSync }\nexport default init;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","var webpackQueues = typeof Symbol === \"function\" ? Symbol(\"webpack queues\") : \"__webpack_queues__\";\nvar webpackExports = typeof Symbol === \"function\" ? Symbol(\"webpack exports\") : \"__webpack_exports__\";\nvar webpackError = typeof Symbol === \"function\" ? Symbol(\"webpack error\") : \"__webpack_error__\";\nvar resolveQueue = (queue) => {\n\tif(queue && !queue.d) {\n\t\tqueue.d = 1;\n\t\tqueue.forEach((fn) => (fn.r--));\n\t\tqueue.forEach((fn) => (fn.r-- ? fn.r++ : fn()));\n\t}\n}\nvar wrapDeps = (deps) => (deps.map((dep) => {\n\tif(dep !== null && typeof dep === \"object\") {\n\t\tif(dep[webpackQueues]) return dep;\n\t\tif(dep.then) {\n\t\t\tvar queue = [];\n\t\t\tqueue.d = 0;\n\t\t\tdep.then((r) => {\n\t\t\t\tobj[webpackExports] = r;\n\t\t\t\tresolveQueue(queue);\n\t\t\t}, (e) => {\n\t\t\t\tobj[webpackError] = e;\n\t\t\t\tresolveQueue(queue);\n\t\t\t});\n\t\t\tvar obj = {};\n\t\t\tobj[webpackQueues] = (fn) => (fn(queue));\n\t\t\treturn obj;\n\t\t}\n\t}\n\tvar ret = {};\n\tret[webpackQueues] = x => {};\n\tret[webpackExports] = dep;\n\treturn ret;\n}));\n__webpack_require__.a = (module, body, hasAwait) => {\n\tvar queue;\n\thasAwait && ((queue = []).d = 1);\n\tif(queue) queue.moduleId = module.id;\n\tvar depQueues = new Set();\n\tvar exports = module.exports;\n\tvar currentDeps;\n\tvar outerResolve;\n\tvar reject;\n\tvar promise = new Promise((resolve, rej) => {\n\t\treject = rej;\n\t\touterResolve = resolve;\n\t});\n\tpromise[webpackExports] = exports;\n\tpromise[webpackQueues] = (fn) => (queue && fn(queue), depQueues.forEach(fn), promise[\"catch\"](x => {}));\n\tpromise.moduleId = module.id;\n\tmodule.exports = promise;\n\tbody((deps) => {\n\t\tcurrentDeps = wrapDeps(deps);\n\t\tvar fn;\n\t\tvar getResult = () => (currentDeps.map((d) => {\n\t\t\tif(d[webpackError]) throw d[webpackError];\n\t\t\treturn d[webpackExports];\n\t\t}))\n\t\tvar promise = new Promise((resolve) => {\n\t\t\tfn = () => (resolve(getResult));\n\t\t\tfn.r = 0;\n\t\t\tvar fnQueue = (q) => (q !== queue && !depQueues.has(q) && (depQueues.add(q), q && !q.d && (fn.r++, q.push(fn))));\n\t\t\tcurrentDeps.map((dep) => (dep[webpackQueues](fnQueue)));\n\t\t});\n\t\treturn fn.r ? promise : getResult();\n\t}, (err) => ((err ? reject(promise[webpackError] = err) : outerResolve(exports)), resolveQueue(queue)));\n\tqueue && (queue.d = 0);\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","// This function allow to reference async chunks\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".js\";\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript)\n\t\tscriptUrl = document.currentScript.src\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) scriptUrl = scripts[scripts.length - 1].src\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","__webpack_require__.b = self.location + \"\";\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t\"src_adapter_ts\": 1\n};\n\n// no chunk install function needed\n// no chunk loading\n\n// no HMR\n\n// no HMR manifest","","// startup\n// Load entry module and return exports\n// This entry module used 'module' so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./src/adapter.ts\");\n",""],"names":[],"sourceRoot":""}